package getl.firebird

import getl.driver.Driver
import getl.jdbc.JDBCDataset
import getl.jdbc.JDBCDriver
import groovy.transform.InheritConstructors

/**
 * Firebird driver class
 * @author Alexsey Konstantinov
 *
 */
@InheritConstructors
class FirebirdDriver extends JDBCDriver {
    @Override
    protected void initParams() {
        super.initParams()

        connectionParamBegin = '?'
        connectionParamJoin = ';'

        commitDDL = true
        transactionalDDL = true

        sqlExpressions.now = 'cast(\'NOW\' as timestamp)'
        sqlExpressions.sequenceNext = "SELECT NEXT VALUE FOR {value} AS id FROM {sysDualTable}"
        sqlExpressions.sysDualTable = 'RDB$DATABASE'
        sqlExpressions.ddlAutoIncrement = 'GENERATED BY DEFAULT AS IDENTITY'
    }

    @SuppressWarnings("UnnecessaryQualifiedReference")
    @Override
    List<Driver.Support> supported() {
        return super.supported() +
            [Driver.Support.GLOBAL_TEMPORARY, Driver.Support.SEQUENCE, Driver.Support.BLOB, Driver.Support.INDEX,
             Driver.Support.TIME, Driver.Support.DATE, Driver.Support.BOOLEAN] -
            [Driver.Support.DEFAULT_VALUE, Driver.Support.COMPUTE_FIELD, Driver.Support.DATABASE, Driver.Support.SCHEMA]
        /* TODO: rewrite for create table when DEFAULT before NOT NULL */
    }

    @SuppressWarnings("UnnecessaryQualifiedReference")
    @Override
    List<Driver.Operation> operations() {
        return super.operations() +
                [Driver.Operation.DROP, Driver.Operation.EXECUTE,
                 Driver.Operation.CREATE]
    }

    @Override
    String defaultConnectURL() {
        return 'jdbc:firebirdsql://{host}/{database}'
    }

    @SuppressWarnings("UnnecessaryQualifiedReference")
    @Override
    Map getSqlType() {
        Map res = super.getSqlType()
        res.BLOB.useLength = JDBCDriver.sqlTypeUse.NEVER

        return res
    }

    @Override
    void sqlTableDirective(JDBCDataset dataset, Map params, Map dir) {
        super.sqlTableDirective(dataset, params, dir)

        if (params.offs != null) {
            dir.afterOrderBy = ((dir.afterOrderBy != null) ? (dir.afterOrderBy + '\n') : '') + "OFFSET ${params.offs} ROWS"
            params.offs = null
        }

        if (params.limit != null) {
            dir.afterOrderBy = ((dir.afterOrderBy != null) ? (dir.afterOrderBy + '\n') : '') + "FETCH FIRST ${params.limit} ROWS ONLY"
            params.limit = null
        }
    }

    @Override
    Boolean blobReadAsObject() { return false }
}