//file:noinspection DuplicatedCode
package getl.firebird

import getl.data.Field
import getl.driver.Driver
import getl.exception.InternalError
import getl.jdbc.JDBCDataset
import getl.jdbc.JDBCDriver
import getl.jdbc.QueryDataset
import getl.jdbc.TableDataset
import getl.utils.ConvertUtils
import groovy.transform.InheritConstructors

/**
 * Firebird driver class
 * @author Alexsey Konstantinov
 *
 */
@InheritConstructors
class FirebirdDriver extends JDBCDriver {
    @Override
    protected void initParams() {
        super.initParams()

        connectionParamBegin = '?'
        connectionParamJoin = ';'

        transactionalDDL = true
        allowColumnsInDefinitionExpression = false
        allowChangeTypePrimaryKeyField = false

        caseObjectName = 'UPPER'
        caseRetrieveObject = 'UPPER'
        ruleEscapedText.put('\'', '\'\'')
        ruleEscapedText.remove('\n')
        ruleEscapedText.remove('\\')

        sqlExpressions.now = 'CURRENT_TIMESTAMP'
        sqlExpressions.sequenceNext = "SELECT NEXT VALUE FOR {value} AS id FROM {sysDualTable}"
        sqlExpressions.sysDualTable = 'RDB$DATABASE'
        sqlExpressions.ddlCreateTable = '{%ifNotExists%}CREATE{ %type%} TABLE {tableName} (\n{fields}\n{pk}\n)\n{extend}'
        sqlExpressions.ddlCreateField = '{column}{ %type%}{ %increment%}{ %default%}{ %check%}{ %compute%}{ %not_null%}'
        sqlExpressions.ddlAddColumnTable = 'ALTER TABLE {tableName} ADD {fieldDesc}'
        sqlExpressions.ddlAutoIncrement = 'GENERATED BY DEFAULT AS IDENTITY'
        sqlExpressions.ddlChangeTypeColumnTable = 'ALTER TABLE {tableName} ALTER COLUMN {fieldName} TYPE {typeName}'
        sqlExpressions.ddlDropColumnTable = 'ALTER TABLE {tableName} DROP {fieldName}'

        sqlTypeMap.BLOB.useLength = sqlTypeUse.NEVER
        sqlTypeMap.TEXT.name = 'blob sub_type text'
        sqlTypeMap.TEXT.useLength = sqlTypeUse.NEVER

        compatibleFieldType.put(Field.stringFieldType, [])
        compatibleFieldType.put(Field.integerFieldType, [Field.bigintFieldType, Field.stringFieldType])
        compatibleFieldType.put(Field.bigintFieldType, [Field.bigintFieldType, Field.stringFieldType])
        compatibleFieldType.put(Field.numericFieldType, [Field.stringFieldType])
        compatibleFieldType.put(Field.doubleFieldType, [Field.stringFieldType])
        compatibleFieldType.put(Field.booleanFieldType, [Field.stringFieldType])

        sqlExpressionSqlTimestampFormat = 'yyyy-MM-dd HH:mm:ss.SSS'

        createViewTypes = ['CREATE']

        ruleNameNotQuote = '(?i)^[a-z]+[a-z0-9_]*$'
        driverSqlKeywords.addAll(['VALUE', 'RECREATE'])
    }

    @SuppressWarnings("UnnecessaryQualifiedReference")
    @Override
    List<Driver.Support> supported() {
        return super.supported() +
            [Support.GLOBAL_TEMPORARY, Support.SEQUENCE, Support.BLOB, Support.CLOB, Support.INDEX, Support.INDEXFORTEMPTABLE, Support.TIME, Support.DATE,
             Support.TIMESTAMP_WITH_TIMEZONE, Support.COLUMN_CHANGE_TYPE, Support.AUTO_INCREMENT] -
            [Support.DATABASE, Support.SCHEMA, Support.SELECT_WITHOUT_FROM]
    }

    @SuppressWarnings("UnnecessaryQualifiedReference")
    @Override
    List<Driver.Operation> operations() {
        return super.operations() - [Operation.CREATE_SCHEMA, Operation.TRUNCATE, Operation.RENAME_TABLE]
    }

    @Override
    String defaultConnectURL() {
        return 'jdbc:firebirdsql://{host}/{database}'
    }

    @Override
    void sqlTableDirective(JDBCDataset dataset, Map params, Map dir) {
        super.sqlTableDirective(dataset, params, dir)

        if (params.offs != null && ConvertUtils.Object2Long(params.offs) > 0) {
            dir.afterOrderBy = ((dir.afterOrderBy != null) ? (dir.afterOrderBy + '\n') : '') + "OFFSET ${params.offs} ROWS"
            params.offs = null
        }

        if (params.limit != null && ConvertUtils.Object2Long(params.limit) > 0) {
            dir.afterOrderBy = ((dir.afterOrderBy != null) ? (dir.afterOrderBy + '\n') : '') + "FETCH FIRST ${params.limit} ROWS ONLY"
            params.limit = null
        }
    }

    /** Current Firebird connection */
    @SuppressWarnings('unused')
    FirebirdConnection getCurrentFirebirdConnection() { connection as FirebirdConnection }

    /*@Override
    String generateDefaultDefinition(Field f) {
        return "DEFAULT (${f.defaultValue})"
    }*/

    @Override
    Boolean blobReadAsObject(Field field = null) { return false }

    @Override
    Boolean textReadAsObject () { return false }

    @Override
    String textMethodWrite (String methodName) {
        return """void $methodName (java.sql.Connection con, java.sql.PreparedStatement stat, Integer paramNum, String value) {
	if (value == null) { 
		stat.setNull(paramNum, java.sql.Types.CLOB) 
	}
	else {
		stat.setString(paramNum, value)
	} 
}"""
    }

    @Override
    protected Map<String, Object> createTableParams(JDBCDataset dataset, String tableTypeName, Boolean validExists, String fields, String pk, String extend,
                                                    Map<String, Object> params) {
        def res = super.createTableParams(dataset, tableTypeName, validExists, fields, pk, extend, params)
        res.ifNotExists = (validExists)?'RE':null
        return res
    }

    static private final String ReadPrimaryKeyConstraintName = '''SELECT "RDB$CONSTRAINT_NAME" AS CONSTRAINT_NAME
FROM "RDB$RELATION_CONSTRAINTS"
WHERE 
    "RDB$CONSTRAINT_TYPE" = 'PRIMARY KEY'
    AND Lower("RDB$RELATION_NAME") = '{table}' '''

    @Override
    String primaryKeyConstraintName(TableDataset table) {
        def q = new QueryDataset()
        q.connection = connection
        q.query = ReadPrimaryKeyConstraintName
        q.queryParams.table = table.tableName.toLowerCase()
        def r = q.rows()
        if (r.size() > 1)
            throw new InternalError(table, 'Error reading primary key from list of constraints', "${r.size()} records returned")

        return (!r.isEmpty())?r[0].constraint_name as String:null
    }
}